package MirageCompiler/Tokenizer

import Constants
import MirageCompiler/{Token, TokenType}

object Tokenizer

String validNameChars = Constants.alphabet + Constants.numbers + "_"
String validNumberChars = Constants.numbers + "."
String validSymbolChars = "()[]{}<>+-*/=,."

String nameStarters = Constants.alphabet + "#$"
String numberStarters = Constants.numbers
String symbolStarters = validSymbolChars

FSM[SymbolState, (String-1, TokenizerState), (Seq[Token], TokenizerState)] symbolFSM = FSM()
{
    // Exclusivity isn't perfectly checked because that's likely impossible. It's checked by verifying that mutual
    // scopes don't have any overlap in their type annotations. This is equivalent to smart dead code detection.
    // For instance char == "." will change String-1 char's type to String-1-Dot and validNumberChars.contains(char)
    // will change String-1 char's type to String-1-In#validNumberChars which has overlap because "." is also in
    // validNumberChars. Additionally String-1-Dot char would cause dead code detection on
    // if (not validNumberChars.contains(char)) { ... }.
    // An ephemeral state is an exclusive state that must transition. This is also compile time checked.
    addExclusiveState(SymbolState.Comment,      commentAction)
    addEphemeralState(SymbolState.Escaped,      addCharAction)
    addExclusiveState(SymbolState.Float,        addCharAction)
    addExclusiveState(SymbolState.Int,          addCharAction)
    addEphemeralState(SymbolState.IntDot,       addCharAction)
    addExclusiveState(SymbolState.IntDotError,  intDotErrorAction)
    addExclusiveState(SymbolState.Name,         addCharAction)
    addExclusiveState(SymbolState.String,       addCharAction)
    addExclusiveState(SymbolState.Symbol,       symbolAction)
    addExclusiveState(SymbolState.Whitespace,   whitespaceAction)

    addTransition(SymbolState.Whitespace,   SymbolState.Int,    whitespaceToInt)
    addTransition(SymbolState.Whitespace,   SymbolState.Name,   whitespaceToName)
    addTransition(SymbolState.Whitespace,   SymbolState.String, whitespaceToString)
    addTransition(SymbolState.Whitespace,   SymbolState.Symbol, toSymbol)

    addTransition(SymbolState.Comment,  SymbolState.Whitespace, commentToWhitespace)
    addTransition(SymbolState.Float,    SymbolState.Whitespace, floatToWhitespace)
    addTransition(SymbolState.Int,      SymbolState.Whitespace, intToWhitespace)
    addTransition(SymbolState.Name,     SymbolState.Whitespace, nameToWhitespace)
    addTransition(SymbolState.String,   SymbolState.Whitespace, stringToWhitespace)
    addTransition(SymbolState.Symbol,   SymbolState.Whitespace, symbolToWhitespace)

    addTransition(SymbolState.Float,    SymbolState.Symbol, toSymbol)
    addTransition(SymbolState.Int,      SymbolState.Symbol, toSymbol)
    addTransition(SymbolState.Name,     SymbolState.Symbol, toSymbol)
    addTransition(SymbolState.String,   SymbolState.Symbol, toSymbol)

    addTransition(SymbolState.Symbol,   SymbolState.Comment,    symbolToComment)

    addTransition(SymbolState.String,   SymbolState.Escaped,    stringToEscaped)
    addTransition(SymbolState.Escaped,  SymbolState.String,     escapedToString)

    addTransition(      SymbolState.Int,    SymbolState.IntDot,     intToIntDot)
    addTransition(      SymbolState.IntDot, SymbolState.Float,      intDotToFloat)
    addTransition(      SymbolState.IntDot, SymbolState.Name,       intDotToName)
    addElseTransition(  SymbolState.IntDot, SymbolState.IntDotError)
}

Bool whitespaceToInt((String-1 char, TokenizerState state))
{
    numberStarters.contains(char)
}

Bool whitespaceToName((String-1 char, TokenizerState state))
{
    nameStarters.contains(char)
}

Bool whitespaceToString((String-1 char, TokenizerState state))
{
    char == "\""
}

Bool toWhitespace((String-1 char, TokenizerState state))(TokenizerExceptionType exceptionType, Fn[String-1, Bool] isInvalidFn)
{
    switch (char)
    case ("\n")
    case (" ")
    {
        true
    }
    case (isInvalidFn)
    {
        throw TokenizerException(exceptionType, state.lineNum, state.columnNum, char)
    }
    case
    {
        false
    }
}

Bool commentToWhitespace((String-1 char, TokenizerState state))
{
    char == "\n"
}

Bool stringToWhitespace((String-1 char, TokenizerState state))
{
    switch (char)
    case ("\"")
    {
        true
    }
    case ("\n")
    {
        throw TokenizerException(TokenizerExceptionType.StringNotTerminated, state.lineNum, state.columnNum, "\\n")
    }
    case
    {
        false
    }
}

Fn[(String-1, TokenizerState), Bool] floatToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInNumber,
    (String-1 char) { not validNumberChars.contains(char) })

Fn[(String-1, TokenizerState), Bool] intToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInNumber,
    (String-1 char) { not validNumberChars.contains(char) })

Fn[(String-1, TokenizerState), Bool] stringToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInName,
    (String-1 char) { not validNameChars.contains(char) })

Fn[(String-1, TokenizerState), Bool] symbolToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInSymbol,
    (String-1 char) { not validSymbolChars.contains(char) })

Bool intToIntDot((String-1 char, TokenizerState state))
{
    char == "."
}

Bool intDotToFloat((String-1 char, TokenizerState state))
{
    Constants.numbers.contains(char)
}

Bool intDotToName((String-1 char, TokenizerState state))
{
    nameStarters.contains(char)
}

Bool symbolToComment((String-1 char, TokenizerState state))
{
    char == "/" and state.symbolText == "/"
}

Bool toSymbol((String-1 char, TokenizerState state))
{
    symbolStarters.contains(char)
}

Bool stringToEscaped((String-1 char, TokenizerState state))
{
    char == "\\"
}

Bool escapedToString((String-1 char, TokenizerState state))
{
    true
}

(Seq[Token], TokenizerState) addCharAction(
    SymbolState previousSymbolState,
    (String-1 char, TokenizerState tokenizerState))
{
    TokenizerState newState = copy (tokenizerState)
        {
            symbolText += char
            columnNum += 1
        }

    (Nil, newState)
}

(Seq[Token], TokenizerState) intDotErrorAction(
    SymbolState previousSymbolState,
    (String-1 char, TokenizerState tokenizerState))
{
    throw TokenizerException(TokenizerExceptionType.UnexpectedDot, state.lineNum, state.columnNum, char)
}

(Seq[Token], TokenizerState) commentAction(
    SymbolState previousSymbolState,
    (String-1 char, TokenizerState tokenizerState))
{
    (Nil, tokenizerState)
}

(Option[Token], TokenizerState) maybeUnpackToken(TokenizerState tokenizerState, SymbolState previousSymbolState)
{
    if (tokenizerState.symbolText.size > 0)
    {
        Option[TokenType] maybeTokenType = switch (previousSymbolState)
        case (SymbolState.Float)
        {
            Some(TokenType.Float)
        }
        case (SymbolState.Int)
        {
            Some(TokenType.Int)
        }
        case (SymbolState.Name)
        {
            // Check if this is a keyword and use the appropriate token type
            Some(TokenType.get(tokenizerState.symbolText).getOrElse(TokenType.Name))
        }
        case (SymbolState.String)
        {
            Some(TokenType.String)
        }
        case (SymbolState.Symbol)
        {
            // Get the approprtiate token type. If the compiler is powerful enough this exception can be determined to
            // be impossible.
            Some(TokenType.get(tokenizerState.symbolText).getOrElse(throw TokenizerException(
                TokenizerExceptionType.UnknownSymbol,
                tokenizerState.lineNum
                tokenizerState.symbolStartColumn,
                tokenizerState.symbolText)))
        }
        case
        {
            None
        }

        Option[Token] maybeToken = maybeTokenType.map((TokenType type)
            {
                Token(type, tokenizerState.lineNum, tokenizerState.lineNum, tokenizerState.symbolStartColumn)
            })

        TokenizerState newState = copy (tokenizerState)
        {
            symbolText = ""
            symbolStartColumn = columnNum
        }

        (maybeToken, newState)
    }
    else
    {
        (None, tokenizerState)
    }
}


(Seq[Token], TokenizerState) symbolAction(
    SymbolState previousSymbolState,
    (String-1 char, TokenizerState tokenizerState))
{
    // TODO
}

(Seq[Token], TokenizerState) whitespaceAction(
    SymbolState previousSymbolState,
    (String-1 char, TokenizerState tokenizerState))
{
    // TODO
    Option[Token] maybePreviousToken = switch (previousSymbolState)
        case (SymbolState.None)
        {

        }

    (Option[Token] maybeToken, TokenizerState newTokenizerState) = switch (char)
        case ("\n")
        {
            (
                Some(Token(TokenType.Newline, "\\n", tokenizerState.lineNum, tokenizerState.columnNum)),
                copy (tokenizerState)
                {
                    lineNum += 1
                    columnNum = 1
                    singleSlash = false
                }
            )
        }
        case (" ")
        {

        }
        case
        {

        }

    (Seq(maybePreviousToken, maybeToken).flatten, newTokenizerState)
}

(Seq[Token], TokenizerState) step(String-1 char, (Seq[Token] tokens, TokenizerState state))
{
    (Seq[Token] newTokens, TokenizerState newState) = FSM.step((char, state))
    
    (tokens.append(newTokens), newState)
}

Seq[Token] tokenize(String plaintext) throws TokenizerException
{
    plaintext.fold((Nil, TokenizerState("", 1, 1, 1)), step)
}
