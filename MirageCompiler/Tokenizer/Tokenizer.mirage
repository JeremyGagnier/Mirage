package MirageCompiler/Tokenizer

import Constants
import MirageCompiler/{Token, TokenType}

object Tokenizer

String validNameChars = Constants.alphabet + Constants.numbers + "_"
String validNumberChars = Constants.numbers + "."
String validSymbolChars = "()[]{}<>+-*/=,."

String nameStarters = Constants.alphabet + "#$"
String numberStarters = Constants.numbers
String symbolStarters = validSymbolChars

FSM[TokenState, (String-1, TokenizerState), (Seq[Token], TokenizerState)] symbolFSM = FSM()
{
    // Exclusivity isn't perfectly checked because that's likely impossible. It's checked by verifying that mutual
    // scopes don't have any overlap in their type annotations. This is equivalent to smart dead code detection.
    // For instance char == "." will change String-1 char's type to String-1-Dot and validNumberChars.contains(char)
    // will change String-1 char's type to String-1-In#validNumberChars which has overlap because "." is also in
    // validNumberChars. Additionally String-1-Dot char would cause dead code detection on
    // if (not validNumberChars.contains(char)) { ... }.
    // An ephemeral state is an exclusive state that must transition. This is also compile time checked.
    addExclusiveState(TokenState.Comment,       commentAction)
    addEphemeralState(TokenState.Escaped,       addCharAction)
    addExclusiveState(TokenState.Float,         addCharAction)
    addExclusiveState(TokenState.Int,           addCharAction)
    addEphemeralState(TokenState.IntDot,        addCharAction)
    addExclusiveState(TokenState.IntDotError,   intDotErrorAction)
    addExclusiveState(TokenState.Name,          addCharAction)
    addExclusiveState(TokenState.String,        addCharAction)
    addExclusiveState(TokenState.Symbol,        symbolAction)
    addExclusiveState(TokenState.Whitespace,    whitespaceAction)

    addTransition(TokenState.Whitespace,    TokenState.Int,     whitespaceToInt)
    addTransition(TokenState.Whitespace,    TokenState.Name,    whitespaceToName)
    addTransition(TokenState.Whitespace,    TokenState.String,  whitespaceToString)
    addTransition(TokenState.Whitespace,    TokenState.Symbol,  toSymbol)

    addTransition(TokenState.Comment,   TokenState.Whitespace,  commentToWhitespace)
    addTransition(TokenState.Float,     TokenState.Whitespace,  floatToWhitespace)
    addTransition(TokenState.Int,       TokenState.Whitespace,  intToWhitespace)
    addTransition(TokenState.Name,      TokenState.Whitespace,  nameToWhitespace)
    addTransition(TokenState.String,    TokenState.Whitespace,  stringToWhitespace)
    addTransition(TokenState.Symbol,    TokenState.Whitespace,  symbolToWhitespace)

    addTransition(TokenState.Float,     TokenState.Symbol,  toSymbol)
    addTransition(TokenState.Int,       TokenState.Symbol,  toSymbol)
    addTransition(TokenState.Name,      TokenState.Symbol,  toSymbol)
    addTransition(TokenState.String,    TokenState.Symbol,  toSymbol)

    addTransition(TokenState.Symbol,    TokenState.Comment, symbolToComment)

    addTransition(      TokenState.String,  TokenState.Escaped, stringToEscaped)
    addElseTransition(  TokenState.Escaped, TokenState.String)

    addTransition(      TokenState.Int,     TokenState.IntDot,  intToIntDot)
    addTransition(      TokenState.IntDot,  TokenState.Float,   intDotToFloat)
    addTransition(      TokenState.IntDot,  TokenState.Name,    intDotToName)
    addElseTransition(  TokenState.IntDot,  TokenState.IntDotError)
}

Bool whitespaceToInt((String-1 char, TokenizerState state))
{
    numberStarters.contains(char)
}

Bool whitespaceToName((String-1 char, TokenizerState state))
{
    nameStarters.contains(char)
}

Bool whitespaceToString((String-1 char, TokenizerState state))
{
    char == "\""
}

Bool toWhitespace((String-1 char, TokenizerState state))(TokenizerExceptionType exceptionType, Fn[String-1, Bool] isInvalidFn)
{
    switch (char)
    case ("\n")
    case (" ")
    {
        true
    }
    case (isInvalidFn)
    {
        throw TokenizerException(exceptionType, state.lineNum, state.columnNum, char)
    }
    case
    {
        false
    }
}

Bool commentToWhitespace((String-1 char, TokenizerState state))
{
    char == "\n"
}

Bool stringToWhitespace((String-1 char, TokenizerState state))
{
    switch (char)
    case ("\"")
    {
        true
    }
    case ("\n")
    {
        throw TokenizerException(TokenizerExceptionType.StringNotTerminated, state.lineNum, state.columnNum, "\\n")
    }
    case
    {
        false
    }
}

Fn[(String-1, TokenizerState), Bool] floatToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInNumber,
    (String-1 char) { not validNumberChars.contains(char) })

Fn[(String-1, TokenizerState), Bool] intToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInNumber,
    (String-1 char) { not validNumberChars.contains(char) })

Fn[(String-1, TokenizerState), Bool] stringToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInName,
    (String-1 char) { not validNameChars.contains(char) })

Fn[(String-1, TokenizerState), Bool] symbolToWhitespace = toWhitespace(
    TokenizerExceptionType.BadCharInSymbol,
    (String-1 char) { not validSymbolChars.contains(char) })

Bool intToIntDot((String-1 char, TokenizerState state))
{
    char == "."
}

Bool intDotToFloat((String-1 char, TokenizerState state))
{
    Constants.numbers.contains(char)
}

Bool intDotToName((String-1 char, TokenizerState state))
{
    nameStarters.contains(char)
}

Bool symbolToComment((String-1 char, TokenizerState state))
{
    char == "/" and state.symbolText == "/"
}

Bool toSymbol((String-1 char, TokenizerState state))
{
    symbolStarters.contains(char)
}

Bool stringToEscaped((String-1 char, TokenizerState state))
{
    char == "\\"
}

(Seq[Token], TokenizerState) addCharAction(
    TokenState previousTokenState,
    (String-1 char, TokenizerState tokenizerState))
{
    TokenizerState newState = copy (tokenizerState)
    {
        symbolText += char
        columnNum += 1
    }

    (Nil, newState)
}

(Seq[Token], TokenizerState) intDotErrorAction(
    TokenState previousTokenState,
    (String-1 char, TokenizerState tokenizerState))
{
    throw TokenizerException(TokenizerExceptionType.UnexpectedDot, state.lineNum, state.columnNum, char)
}

(Seq[Token], TokenizerState) commentAction(
    TokenState previousTokenState,
    (String-1 char, TokenizerState tokenizerState))
{
    (Nil, tokenizerState)
}

(Option[Token], TokenizerState) maybeUnpackToken(TokenizerState tokenizerState, TokenState previousTokenState)
{
    if (tokenizerState.symbolText.size > 0)
    {
        Option[TokenType] maybeTokenType = switch (previousTokenState)
        case (TokenState.Float)
        {
            Some(TokenType.Float)
        }
        case (TokenState.Int)
        {
            Some(TokenType.Int)
        }
        case (TokenState.Name)
        {
            // Check if this is a keyword and use the appropriate token type
            Some(TokenType.get(tokenizerState.symbolText).getOrElse(TokenType.Name))
        }
        case (TokenState.String)
        {
            Some(TokenType.String)
        }
        case (TokenState.Symbol)
        {
            // Get the approprtiate token type. If the compiler is powerful enough this exception can be determined to
            // be impossible.
            Some(TokenType.get(tokenizerState.symbolText).getOrElse(throw TokenizerException(
                TokenizerExceptionType.UnknownSymbol,
                tokenizerState.lineNum
                tokenizerState.symbolStartColumn,
                tokenizerState.symbolText)))
        }
        case
        {
            None
        }

        Option[Token] maybeToken = maybeTokenType.map((TokenType type)
            {
                Token(type, tokenizerState.lineNum, tokenizerState.lineNum, tokenizerState.symbolStartColumn)
            })

        TokenizerState newState = copy (tokenizerState)
        {
            symbolText = ""
            symbolStartColumn = columnNum
        }

        (maybeToken, newState)
    }
    else
    {
        (None, tokenizerState)
    }
}


(Seq[Token], TokenizerState) symbolAction(
    TokenState previousTokenState,
    (String-1 char, TokenizerState tokenizerState))
{
    (Option[Token] maybeToken, TokenizerState unpackedState) = if (previousTokenState == TokenState.Symbol)
    {
        (None, tokenizerState)
    }
    else
    {
        maybeUnpackToken(tokenizerState, previousTokenState)
    }

    TokenizerState newState = copy (unpackedState)
    {
        symbolText += char
        columnNum += 1
    }

    (maybeToken.getOrElse(Nil), newState)
}

(Seq[Token], TokenizerState) whitespaceAction(
    TokenState previousTokenState,
    (String-1 char, TokenizerState tokenizerState))
{
    // TODO
    (Option[Token] maybePreviousToken, TokenizerState unpackedState) = maybeUnpackToken(tokenizerState, previousTokenState)
    (Option[Token] maybeToken, TokenizerState newTokenizerState) = switch (char)
    case ("\n")
    {
        Token newToken = Some(Token(TokenType.Newline, "\\n", unpackedState.lineNum, unpackedState.columnNum))
        TokenizerState newState = copy (unpackedState)
        {
            lineNum += 1
            columnNum = 1
            singleSlash = false
        }
        (Some(newToken), newState)
    }
    case (" ")
    {

    }
    case
    {

    }

    (Seq(maybePreviousToken, maybeToken).flatten, newTokenizerState)
}

(Seq[Token], TokenizerState) step(String-1 char, (Seq[Token] tokens, TokenizerState state))
{
    (Seq[Token] newTokens, TokenizerState newState) = FSM.step((char, state))

    (tokens.append(newTokens), newState)
}

Seq[Token] tokenize(String plaintext) throws TokenizerException
{
    plaintext.fold((Nil, TokenizerState("", 1, 1, 1)), step)
}
